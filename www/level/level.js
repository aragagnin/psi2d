/*
 Psi2d.

 The Level class holds a set of tiles and player.
 Tiles are generated by the famous tiled map (https://www.mapeditor.org).


 the Level also exposes the function simulateTo(time) that integrates the state
 of the level up to a given time t.
 Integration step is this.dt and each step is performed by the function step(time, dt).
 The function step actually calls all Element' function step(time, dt) that
 must integrate themselves.

*/

"use strict";
(function(exports) {

    var utils = require('./utils')
    var elements = require('./elements')
    var Clock = elements.Clock

    function cell(x, y) {
        return tcell(p2t(x), p2t(y));
    }


    function overlap(pos1, size1, pos2, size2) {
        var x1 = pos1[0],
            y1 = pos1[1],
            w1 = size1[0] - 0.1,
            h1 = size1[1] - 0.1,
            x2 = pos2[0],
            y2 = pos2[1],
            w2 = size2[0] - 0.1,
            h2 = size2[1] - 0.1; //remove 0.1 to not make it too difficuklt
        return !(((x1 + w1) < x2) ||
            ((x2 + w2) < x1) ||
            ((y1 + h1) < y2) ||
            ((y2 + h2) < y1))
    }

    function Level() {
        this.elements = []; //list of dynamic elements in the game
        this.debug = false
	this.time = 0; //integration time
        this.grid = []; //note: grid contains only static objects
        this.spawnpoints = [] //list of spawnpoints in the game
        this.last_uid = 0;
        this.players = [] //list of players in the game
        this.maxAmmo = 10
        this.isServer = false 
        this.isClient = false
        this.server = null;
        this.time = null;
        this.cname = 'Level';
    }

    Level.prototype = {
	/*
	  each block has a uniq ID
	 */
        nextUid: function() {
            this.last_uid += 1
            return  this.last_uid;
        },
	/*
	  integrate the level up to time t, gven a timestep dt.
	  this function breakes the integration interval time in chunks of dt
	  and execute the step function
	 */
        integrate: function(time, dt) {
            var to = time;
            if (to < this.time) {
                throw new Error(["not goint to simulate past time=", time, dt, "this.time=", this.time, 'time - this.time = ', time - this.time])
                return
            }
            var DeltaT = to - from;
            for (var from = this.time; from <= to; from += dt) {
                var real_dt = Math.min(dt, to - from);
		if(real_dt==0){
		    break; //time step zero will not be integrated
		}
                if (this.debug) console.log(this.time, '->', this.time + real_dt, '(', real_dt, ')')
                this.step(real_dt);
                this.time = this.time + real_dt
            }
            this.time = to;
        },
        simulateTo: function(time) {
            if (this.debug) console.log('simulo da', this.time, '>', time, 'clocks:', this.players[0].clocks)
            this.integrate(time, this.dt)
        },
	/*
	  evolve all elements of a single dt
	 */
        step: function(dt) {
            for (var i = 0; i < this.elements.length; i++) {
                this.elements[i].step(this, dt);
            }
            for (var j = 0; j < this.players.length; j++) {
                var player = this.players[j];
		if (player.pos!=null && (isNaN(player.pos[0])||isNaN(player.pos[1]))){
		    console.log(player);
		    throw "pre step: pos is nan";
		}
                player.step(this, dt);
		if (player.pos!=null && (isNaN(player.pos[0])||isNaN(player.pos[1]))){
		    console.log(player);
		    throw "post step: pos is nan";
		}
                if (player.alive) {
		    
                    for (var i = 0; i < this.elements.length; i++) {
                        var element = this.elements[i];
                        if (player.pos!=null && overlap(element.pos, element.size, player.pos, player.size)) {

                            if (element.awake) {
                                if (element.intersects) element.intersects(this, player)
                            }

                        }
                    }
                    if (player.life <= 0 && this.isServer) { //player died now
                        player.alive = false
			var respawns = player.respawns+1;
                        var uid = player.uid

                        this.broadcast.push({
                            uid: player.uid,
                            alive: player.alive
                        })
                        this.broadcast.push({
                            c: player.name + ' died.'// Now:'+this.time.toString()+' Respawn time:'+(  player.respawn).toString()
                        })
                        var clock = new Clock(function(e, game) {
                            game.spawn(e);
			    e.respawns=respawns;
                            game.broadcast.push(e); //update player status
                            game.broadcast.push({
                                c: e.name + ' lives again'
                            })
                            //game.broadcast.push({
                            //    uid: player.uid, pos: player.pos, alive: player.alive
                            //})
                        }, this.time + player.respawn)
                        player.clocks.push(clock)

                    }
                }
            }
            var that = this
	    /*
	      trash elements that are flagged with the trash flag
	     */
            function trash(e) {
                var c = !e.trash;
                if (!c) {
                    that.broadcast.push({
                        uid: e.uid,
                        trash: true
                    })
                    if (e.player) that.broadcast.push({
                        c: e.name + ' left'
                    })
                };
                return c;
            }
            this.elements = this.elements.filter(trash)
            this.players = this.players.filter(trash)
            var game = this;

        }

    }

    Level.prototype.getByUid = function(uid) {
        if (uid === undefined) {
            throw new Error("uid is undefined :(")
        }
        for (var i in this.elements) {
            if (this.elements[i].uid == uid) return this.elements[i]
        }
        for (var i in this.players) {
            if (this.players[i].uid == uid) return this.players[i]
        }
    }

/*
  the map grid is saved in a grid that you can access from
  this.grid[[i,j]].
  this function finds all eleemnts in a rectangle
*/
    Level.prototype.pgrid = function(x, y, w, h) {
        var g = this.grid
        var res = false
        var myx, myy, v, s;
        for (var i = 0; i < w; i++) {
            for (var j = 0; j < h; j++) {
                myx = parseInt(x) + i
                myy = parseInt(y) + j
                v = [myx, myy]
                if (this.grid[v] && this.grid[v].length > 0) {
                    for (var k = 0; k < this.grid[v].length; k++) {
                        if (this.grid[v][k].block) return true
                    }
                }
            }
        }
        return false
    }
    //spawn a player
    Level.prototype.spawn = function(player) {
        if (player.alive == false) {
            this.last_sp = (this.last_sp + 1) % this.spawnpoints.length
            player.pos = [this.spawnpoints[this.last_sp][0], this.spawnpoints[this.last_sp][1]] //deepCopy(this.spawnpoints[this.last_sp])
	    console.log('=============> spawn of player ', player.pos);
            player.reset();
        } else {
            throw new Error("spawning an already alive player");
        }
    }
    Level.prototype.screen = function(pos, size, a) {
        var data = []
        for (var k = 0; k < a.length; k++) {
            var e = a[k];
            if (e) {
                var x = e.pos[0];
                var y = e.pos[1];
                if (x < pos[0] + size[0] && x > pos[0] - size[0] && y < pos[1] + size[1] && y > pos[1] - size[1]) {
                    data.push(e);
                }
            }
        }
        return data;
    }


    exports.Level = Level
    //exports.generate_level = generate_level

})(typeof exports === 'undefined' ? this['level'] = {} : exports);
